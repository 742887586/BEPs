```
shortname: BEP-15
name: Ethereum Integration Tools & Demo 1
type: Standard
status: Raw
editor: Troy McConaghy <troy@bigchaindb.com>
```

# Abstract

This BEP lists the requirements of an initial set of tools to integrate BigchainDB with Ethereum, including a demo illustrating how to use the tools.

# Motivation

There is a large community of Ethereum developers. We'd like to make it easy for them to use BigchainDB as part of their Ethereum projects, particularly for data storage and retrieval. We'd like them to be able to do that from their smart contract code, if possible.

By creating some tools, and a demo showing how to use them, we hope to help Ethereum developers get started using BigchainDB in their projects.

# Specification

The tools described below must all work with the Ethereum Mainnet and at least one of the Ethereum testnets.

All smart contract code to implement this BEP must be written in Solidity.

## Tools for Writing Data to an External BigchainDB Network

To write data to any BigchainDB network, one must construct a valid BigchainDB transaction then send it to the network using an HTTP POST request.

To be valid, a BigchainDB transaction must be signed. To sign a transaction, the software doing the signing must have a private key. Since that private key shouldn't be stored in the Ethereum Mainnet (because then it wouldn't be private anymore), it must be signed by a system outside of the Ethereum Mainnet.

In principle, it might be possible for an Ethereum smart contract to construct an un-signed BigchainDB transaction, but that would probably cost a lot of gas, and in the end, some external system must do the final signing anyway.

A better design would use an external system to construct and sign the BigchainDB transaction, possibly containing some information generated (or referenced) by a smart contract in the Ethereum Mainnet. Here is one potential sequence of events:

1. An external system monitors the Ethereum Mainnet, watching for some trigger involving a specific storage smart contract.
1. If that trigger is spotted, the external system springs into action, constructing a new BigchainDB transaction containing data that may be from the storage smart contract, or data that the storage smart contract referenced, such as some data at a particular IPFS hash.
1. The external system signs the transaction.
1. The external system POSTs the transaction to a specific BigchainDB network for validation and storage. The network is either specified by the smart contract or is implied.
1. The external system gets the result of the HTTP POST request. (It either works or it doesn't.) It sends an Ethereum transaction to the storage smart contract to let it know what happened.

Note how the storage smart contract 1) caused the storage to happen and 2) told the external system what to store in the BigchainDB network, at least in part.

The external system should be written using Python or JavaScript, using the [BigchainDB driver](http://docs.bigchaindb.com/projects/server/en/master/drivers-clients/index.html) for the chosen language.

### Remarks

- Each project using these tools will have its own external service (probably self-hosted), and its own storage smart contract.
- There are existing tools and services for monitoring the Ethereum Mainnet. The external system only needs to monitor one smart contract: the storage smart contract.
- The question of _what data to store_ was left ambiguous. The demo could store some data (e.g. a hash) generated by the storage smart contract.
- The data-to-store could be stored in one or more fields of the BigchainDB transaction, including the `asset.data` of a CREATE transaction, the `metadata` of a CREATE or TRANSFER transaction, the `amount` of the single output of a CREATE transaction, or other places.
- The external system must sign the transaction, but using which private key? An initial demo could just re-use the same keypair for all transactions it creates.
- What BigchainDB network should the external system write to? The demo should write to [the BigchainDB Testnet](https://testnet.bigchaindb.com/).

## Tools for Reading Data from an External BigchainDB Network

An Ethereum smart contract can't just make a call to the outside world and take action based on the response. The reason is that the Ethereum blockchain must be deterministic and replayable: one must be able to get back to the current Ethereum state by starting with the initial state and replaying all the stored transactions in order. That wouldn't be possible if some of the current state depended on external information that changed or is no longer available. That doesn't mean external data can't be used at all. It just means that external data must first be stored in the Ethereum blockchain, making it internal, before it can be used.

Once again, an external service is required: an oracle.

While we could implement a new BigchainDB-specific oracle, it would be non-trivial and a deviation from BigchainDB's focus. Therefore, to implement this BEP, we should use an existing, well-known oracle service. [Oraclize](https://docs.oraclize.it/) is one good option, but others might also work, if they can be justified.

The demo should show how to do at least three different queries of the BigchainDB Testnet.

- The queries should rely on queries in the existing [BigchainDB HTTP API](http://docs.bigchaindb.com/projects/server/en/master/http-client-server-api.html).
- One query should return the value of "version" in the response to the BigchainDB Root URL, e.g. "2.0.0b5"
- One query should illustrate how to get the specific data value that was stored in the write demo.

Errors and other exceptions must be handled gracefully.

There will be fees to do get transactions processed, to run the smart contracts, to use the oracle, to store data on-chain, and probably more.

## Additional Requirements

A new public GitHub repository must be created under the `bigchaindb` organization on GitHub, to store all code and documentation written to implement this BEP.

The code should be licensed under an Apache v2 license. The documentation should be licensed under a Creative Commons Attribution 4.0 International license.

The documentation should explain all the steps to set up and run the demo (both writing and reading), including how to set up the external service and the oracle service. That documentation could be written using one or more Markdown files.

The smart contracts must be tested on one of the Ethereum Testnets. The testing code, and some example results, should be included in the GitHub repo. There should be documentation about how to run the test.

# Rationale

We required that all smart contract code be written in Solidity because, at the time of writing, Solidity was the most commonly-used EVM smart contract language.

# Change Process

BigchainDB GmbH has a process to improve BEPs like this one. Please see [BEP-1 (C4)](../1) and [BEP-2 (COSS)](../2).

# Implementation

Once an implementation exists (i.e. in the above-mentioned GitHub repository), add a link to it here.

# Copyright Waiver

_To the extent possible under law, the person who associated CC0 with this work (Troy McConaghy, editor) has waived all copyright and related or neighboring rights to this work._